/*!
 * recursive-iterator v3.3.0
 * https://github.com/nervgh/recursive-iterator
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.RecursiveIterator=e():t.RecursiveIterator=e()}("undefined"!=typeof self?self:this,function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";var n=r(1),i={},o=function(){function t(t,e,r,n){void 0===e&&(e=0),void 0===r&&(r=!1),void 0===n&&(n=100),this.BYPASS_MODE=e,this.IGNORE_CIRCULAR=r,this.MAX_DEEP=n,this.CACHE=[],this.QUEUE=[],this.STATE=this.getState(void 0,t,null)}return t.prototype.next=function(){var t=this.STATE||i,e=t.node,r=t.path,n=t.deep;if(this.MAX_DEEP>n&&this.isNode(e))if(this.isCircular(e)){if(!this.IGNORE_CIRCULAR)throw new Error("Circular reference")}else if(this.onStepInto(this.STATE)){var o=this.getStatesOfChildNodes(e,r,n),s=this.BYPASS_MODE?"push":"unshift";(u=this.QUEUE)[s].apply(u,o),this.CACHE.push(e)}var u,f=this.QUEUE.shift(),p=!f;return this.STATE=f,p&&this.destroy(),{value:f,done:p}},t.prototype.destroy=function(){this.QUEUE.length=0,this.CACHE.length=0,this.STATE=null},t.prototype.isNode=function(t){return n.isObject(t)},t.prototype.isLeaf=function(t){return!this.isNode(t)},t.prototype.isCircular=function(t){return-1!==this.CACHE.indexOf(t)},t.prototype.getStatesOfChildNodes=function(t,e,r){var i=this;return n.getKeys(t).map(function(n){return i.getState(t,t[n],n,e.concat(n),r+1)})},t.prototype.getState=function(t,e,r,n,i){return void 0===n&&(n=[]),void 0===i&&(i=0),{parent:t,node:e,key:r,path:n,deep:i}},t.prototype.onStepInto=function(t){return!0},t.prototype[Symbol.iterator]=function(){return this},t}();t.exports=o},function(t,e,r){"use strict";function n(t){return null!==t&&"object"==typeof t}Object.defineProperty(e,"__esModule",{value:!0}),e.isObject=n;var i=Array.isArray;function o(t){if(!n(t))return!1;if(!("length"in t))return!1;var e=t.length;if(!s(e))return!1;if(e>0)return e-1 in t;for(var r in t)return!1}function s(t){return"number"==typeof t}e.isArray=i,e.isArrayLike=o,e.isNumber=s,e.getKeys=function(t){var e=Object.keys(t);if(i(t));else if(o(t)){var r=e.indexOf("length");r>-1&&e.splice(r,1)}else e.sort();return e}}])});
//# sourceMappingURL=recursive-iterator.min.js.map